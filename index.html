<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
<pre>
        ----------------------------------------------------------------------------------------------------------------
        ----------------------------------------------------------------------------------------------------------------
        DC EXPERIMENT
        ----------------------------------------------------------------------------------------------------------------
        EXP1 Client Server Implementation using Socket Programming: 
        i. One server to one client (Same device) 
        import java.io.*;
        import java.net.*;
        
        public class Server {
            public static void main(String[] args) {
                try {
                    ServerSocket serverSocket = new ServerSocket(12345);
                    System.out.println("Server is waiting for connection...");
        
                    Socket clientSocket = serverSocket.accept();
                    System.out.println("Client connected.");
        
                    DataInputStream in = new DataInputStream(clientSocket.getInputStream());
                    DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());
        
                    String message = in.readUTF();
                    System.out.println("Received from client: " + message);
        
                    out.writeUTF("Hello from server!");
        
                    in.close();
                    out.close();
                    clientSocket.close();
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        import java.io.*;
        import java.net.*;
        
        public class Client {
            public static void main(String[] args) {
                try {
                    Socket socket = new Socket("127.0.0.1", 12345);
                    System.out.println("Connected to server.");
        
                    DataInputStream in = new DataInputStream(socket.getInputStream());
                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());
        
                    out.writeUTF("Hello from client!");
        
                    String response = in.readUTF();
                    System.out.println("Received from server: " + response);
        
                    in.close();
                    out.close();
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        STEPS:
        1.Open any text editor (like Notepad) and paste the Server code. Save the file as Server.java.
        2.Open another new text file and paste the Client code. Save the file as Client.java.
        3.Open a Command Prompt or Terminal.
        4.Navigate to the folder where the Server.java and Client.java files are saved.
        5.Compile the Server file by typing: javac Server.java
        6.Compile the Client file by typing: javac Client.java
        7.Now, open a second Command Prompt or Terminal window.
        8.In the first terminal, run the Server by typing: java Server
        9.In the second terminal, run the Client by typing: java Client
        10.The Server terminal will display:
        "Server is waiting for connection..."
        "Client connected."
        "Received from client: Hello from client!"
        11.The Client terminal will display:
        "Connected to server."
        "Received from server: Hello from server!"
        
        
        ii. One server to one client (Different devices)
        import java.io.*;
        import java.net.*;
        
        public class Server {
            public static void main(String[] args) {
                try {
                    InetAddress localHost = InetAddress.getLocalHost();
                    String serverIp = localHost.getHostAddress();
                    System.out.println("Server has started. IP Address: "+ serverIp);
        
                    ServerSocket serverSocket = new ServerSocket(12345);
                    System.out.println("Server is waiting for connection...");
        
                    Socket clientSocket = serverSocket.accept();
                    System.out.println("Client connected.");
        
                    DataInputStream in = new DataInputStream(clientSocket.getInputStream());
                    DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());
        
                    String message = in.readUTF();
                    System.out.println("Received from client: " + message);
        
                    out.writeUTF("Hello from server!");
        
                    in.close();
                    out.close();
                    clientSocket.close();
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        
        import java.io.*;
        import java.net.*;
        
        public class Client {
            public static void main(String[] args) {
                try {
                    InetAddress localHost = InetAddress.getLocalHost();
                    String clientIp = localHost.getHostAddress();
                    System.out.println("Client has started. IP Address: " + clientIp);
        
                    Socket socket = new Socket("192.168.1.152", 12345);
                    System.out.println("Connected to server.");
        
                    DataInputStream in = new DataInputStream(socket.getInputStream());
                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());
        
                    out.writeUTF("Hello from client!");
        
                    String response = in.readUTF();
                    System.out.println("Received from server: " + response);
        
                    in.close();
                    out.close();
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        STEPS:
        1.Make sure both the Server and Client devices are connected to the same Wi-Fi or LAN network.
        2.On the server device, open a text editor and paste the Server code. Save it as Server.java.
        3.On the client device, open a text editor and paste the Client code. Save it as Client.java.
        4.In the Client code, replace the IP address 192.168.1.152 with the actual IP address of the server. You can find the server's IP address using ipconfig (on Windows) or ifconfig (on Linux/Mac).
        5.On the server device, open a terminal and navigate to the folder where Server.java is saved.
        6.Compile the Server file: javac Server.java
        7.Run the Server: java Server
        8.On the client device, open a terminal and navigate to the folder where Client.java is saved.
        9.Compile the Client file: javac Client.java
        10.Run the Client: java Client
        11.The Server terminal will display:
        "Server has started. IP Address: [your IP]"
        "Server is waiting for connection..."
        "Client connected."
        "Received from client: Hello from client!"
        12.The Client terminal will display:
        "Client has started. IP Address: [client IP]"
        "Connected to server."
        "Received from server: Hello from server!"
        
        
        iii. One server to multiple client (Different devices) 
        import java.io.*;
        import java.net.*;
        
        public class ServerMultiple {
            public static void main(String[] args) {
                try {
                    // Server socket bound to port 12345
                    ServerSocket serverSocket = new ServerSocket(12345);
                    System.out.println("Server is waiting for clients...");
        
                    while (true) {
                        // Accept client connection
                        Socket clientSocket = serverSocket.accept();
                        System.out.println("Client connected from IP: " + clientSocket.getInetAddress().getHostAddress());
        
                        // Create a new thread to handle the client
                        new ClientHandler(clientSocket).start();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        class ClientHandler extends Thread {
            private Socket clientSocket;
        
            public ClientHandler(Socket socket) {
                this.clientSocket = socket;
            }
        
            @Override
            public void run() {
                try {
                    // Create input and output streams
                    DataInputStream in = new DataInputStream(clientSocket.getInputStream());
                    DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());
        
                    // Server receives message from client
                    String message = in.readUTF();
                    System.out.println("Received from client: " + message);
        
                    // Server sends response to client
                    out.writeUTF("Hello from server!");
        
                    // Close resources
                    in.close();
                    out.close();
                    clientSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        import java.io.*;
        import java.net.*;
        
        public class Client {
            public static void main(String[] args) {
                try {
                    InetAddress localHost = InetAddress.getLocalHost();
                    String clientIp = localHost.getHostAddress();
                    System.out.println("Client has started. IP Address: " + clientIp);
        
                    Socket socket = new Socket("192.168.1.9", 1234);
        
                    System.out.println("Connected to server.");
        
                    DataInputStream in = new DataInputStream(socket.getInputStream());
                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());
        
                    out.writeUTF("Hello from Dishant!");
        
                    String response = in.readUTF();
                    System.out.println("Received from server: " + response);
        
                    in.close();
                    out.close();
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        STEPS:
        1.Ensure all devices (server and multiple clients) are connected to the same network.
        2.On the server device, open a text editor and paste the ServerMultiple code (along with the ClientHandler class in the same file). Save it as ServerMultiple.java.
        3.On the client devices, open a text editor and paste the Client code. Save it as Client.java.
        4.In each Client file, replace the IP address 192.168.1.9 with the actual IP address of the server device.
        5.Make sure the port number used in the Client code matches the server’s port (use 12345).
        6.On the server device, open a terminal and go to the folder where ServerMultiple.java is saved.
        7.Compile the Server file: javac ServerMultiple.java
        8.Run the Server: java ServerMultiple
        9.On each client device, open a terminal and go to the folder where Client.java is saved.
        10.Compile the Client file: javac Client.java
        11.Run the Client: java Client
        12.Repeat steps 10 and 11 for every client you want to connect.
        13.The Server terminal will display multiple messages like:
        "Client connected from IP: [client IP]"
        "Received from client: Hello from Dishant!"
        14.Each Client terminal will display:
        "Client has started. IP Address: [client IP]"
        "Connected to server."
        "Received from server: Hello from server!"
        ----------------------------------------------------------------------------------------------------------------
        EXP2 Client Server Implementation using RPC/RMI: 
        Implementation RMI:
        import java.rmi.Remote;
        import java.rmi.RemoteException;
        
        public interface ICalculator extends Remote {
            int add(int a, int b) throws RemoteException;
            int subtract(int a, int b) throws RemoteException;
            int multiply(int a, int b) throws RemoteException;
            int divide(int a, int b) throws RemoteException;
        }
        
        
        import java.rmi.RemoteException;
        import java.rmi.server.UnicastRemoteObject;
        
        public class Calculator extends UnicastRemoteObject implements ICalculator {
            protected Calculator() throws RemoteException {
                super();
            }
        
            @Override
            public int add(int a, int b) throws RemoteException {
                return a + b;
            }
        
            @Override
            public int subtract(int a, int b) throws RemoteException {
                return a - b;
            }
        
            @Override
            public int multiply(int a, int b) throws RemoteException {
                return a * b;
            }
        
            @Override
            public int divide(int a, int b) throws RemoteException {
                if (b == 0) throw new ArithmeticException("Division by zero!");
                return a / b;
            }
        }
        
        
        import java.rmi.registry.LocateRegistry;
        import java.rmi.registry.Registry;
        import java.rmi.Naming;
        
        public class CalculatorServer {
            public static void main(String[] args) {
                try {
                    Calculator calculator = new Calculator();
        
                    Registry registry = LocateRegistry.createRegistry(1099);
        
                    Naming.rebind("CalculatorService", calculator);
        
                    System.out.println("Calculator Server is ready.");
                } catch (Exception e) {
                    System.err.println("Server exception: " + e.toString());
                    e.printStackTrace();
                }
            }
        }
        
        
        
        import java.rmi.Naming;
        
        public class CalculatorClient {
            public static void main(String[] args) {
                try {
                    String serverHostname = args.length > 0 ? args[0] : "localhost";
        
                    ICalculator calculator = (ICalculator) Naming.lookup("rmi://" + serverHostname + "/CalculatorService");
        
                    System.out.println("Addition: " + calculator.add(10, 5));
                    System.out.println("Subtraction: " + calculator.subtract(10, 5));
                    System.out.println("Multiplication: " + calculator.multiply(10, 5));
                    System.out.println("Division: " + calculator.divide(10, 5));
                } catch (Exception e) {
                    System.err.println("Client exception: " + e.toString());
                    e.printStackTrace();
                }
            }
        }
        STEPS:
        Server-Side Steps:
        1.Create a folder named "RMI_Calculator".
        2.Inside this folder, create and save the following three Java files:
        ICalculator.java
        Calculator.java
        CalculatorServer.java
        3.Open Command Prompt and navigate to the folder where these files are saved.
        4.Compile all Java files using the javac command.
        5.Open a new Command Prompt window in the same folder and start the RMI registry using the rmiregistry command. Keep this window open.
        6.In the first Command Prompt window, run the CalculatorServer class using the java command.
        7.The server should display the message: "Calculator Server is ready."
        Client-Side Steps:
        1.Create another folder (on the same or different computer) and save the following two Java files:
        ICalculator.java
        CalculatorClient.java
        2.Open Command Prompt and navigate to the folder where these client files are saved.
        3.Compile the Java files using the javac command.
        4.Run the CalculatorClient class using the java command.
        5.The client should display the output:
        Addition: 15
        Subtraction: 5
        Multiplication: 50
        Division: 2
        6.If running on a different computer, replace "localhost" in the client code with the IP address of the server computer.
        
         
        Implementation RPC:
        import java.io.Serializable;
        
        public class CalculatorRequest implements Serializable {
            private static final long serialVersionUID = 1L;  // It's good practice to add a serial version ID
            private int num1;
            private int num2;
            private String operation;
        
            public CalculatorRequest(int num1, int num2, String operation) {
                this.num1 = num1;
                this.num2 = num2;
                this.operation = operation;
            }
        
            public int getNum1() {
                return num1;
            }
        
            public void setNum1(int num1) {
                this.num1 = num1;
            }
        
            public int getNum2() {
                return num2;
            }
        
            public void setNum2(int num2) {
                this.num2 = num2;
            }
        
            public String getOperation() {
                return operation;
            }
        
            public void setOperation(String operation) {
                this.operation = operation;
            }
        }
        
        
        import java.io.*;
        import java.net.*;
        
        public class CalculatorServer {
            public static void main(String[] args) {
                ServerSocket serverSocket = null;
                Socket clientSocket = null;
                ObjectInputStream ois = null;
                ObjectOutputStream oos = null;
        
                try {
                    serverSocket = new ServerSocket(5000);
                    System.out.println("Server is waiting for client...");
        
                    clientSocket = serverSocket.accept();
                    System.out.println("Client connected!");
        
                    ois = new ObjectInputStream(clientSocket.getInputStream());
                    oos = new ObjectOutputStream(clientSocket.getOutputStream());
        
                    CalculatorRequest request = (CalculatorRequest) ois.readObject();
        
                    int result = 0;
                    switch (request.getOperation()) {
                        case "add":
                            result = request.getNum1() + request.getNum2();
                            break;
                        case "subtract":
                            result = request.getNum1() - request.getNum2();
                            break;
                        case "multiply":
                            result = request.getNum1() * request.getNum2();
                            break;
                        case "divide":
                            result = request.getNum1() / request.getNum2();
                            break;
                        default:
                            System.err.println("Invalid operation");
                    }
        
                    oos.writeInt(result);
                    oos.flush();
        
                } catch (IOException | ClassNotFoundException ex) {
                    System.err.println("Error: " + ex.getMessage());
                } finally {
                    try {
                        if (ois != null) ois.close();
                        if (oos != null) oos.close();
                        if (clientSocket != null) clientSocket.close();
                        if (serverSocket != null) serverSocket.close();
                    } catch (IOException ex) {
                        ex.printStackTrace();
                    }
                }
            }
        }
        
        
        
        import java.io.*;
        import java.net.*;
        
        public class CalculatorClient {
            public static void main(String[] args) {
                Socket socket = null;
                ObjectOutputStream oos = null;
                ObjectInputStream ois = null;
               
                try {
                    socket = new Socket("localhost", 5000);
        
                    oos = new ObjectOutputStream(socket.getOutputStream());
                    ois = new ObjectInputStream(socket.getInputStream());
        
                    CalculatorRequest request = new CalculatorRequest(10, 5, "add");
        
                    oos.writeObject(request);
                    oos.flush();
        
                    int result = ois.readInt();
                    System.out.println("Result from server: " + result);
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    try {
                        if (ois != null) ois.close();
                        if (oos != null) oos.close();
                        if (socket != null) socket.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        
        STEPS:
        Server-Side Steps:
        1.Create a folder named "RPC_Calculator".
        2.Inside this folder, create and save the following two Java files:
        CalculatorRequest.java
        CalculatorServer.java
        3.Open Command Prompt and navigate to the folder where these files are saved.
        4.Compile all Java files using the javac command.
        5.Run the CalculatorServer class using the java command.
        6.The server should display the message: "Server is waiting for client..."
        7.When a client connects, it will also display: "Client connected!"
        Client-Side Steps:
        1.Create another folder and save the following two Java files:
        CalculatorRequest.java
        CalculatorClient.java
        2.Open Command Prompt and navigate to the folder where these client files are saved.
        3.Compile the Java files using the javac command.
        4.Run the CalculatorClient class using the java command.
        5.The client should display the result received from the server, for example: "Result from server: 15"
        6.If running on a different computer, replace "localhost" in the client code with the IP address of the server computer.
        ----------------------------------------------------------------------------------------------------------------
        EXP3 Client Server Implementation using CORBA:
        Hello.idl
        module HelloApp {
            interface Hello {
               string sayHello();
               void shutdown();
            };
        };
        
        HelloClient.java
        import HelloApp.*;
        import org.omg.CORBA.*;
        import org.omg.CosNaming.*;
        import org.omg.CosNaming.NamingContextPackage.*;
        
        public class HelloClient {
            public static void main(String args[]) {
                try {
                    // Initialize the ORB
                    ORB orb = ORB.init(args, null);
        
                    // Get the Naming Service reference
                    org.omg.CORBA.Object objRef = orb.resolve_initial_references("NameService");
                    NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
        
                    // Resolve the object reference
                    String name = "Hello";
                    NameComponent path[] = ncRef.to_name(name);
                    Hello helloRef = HelloHelper.narrow(ncRef.resolve(path));
        
                    // Invoke the remote method
                    System.out.println(helloRef.sayHello());
                    helloRef.shutdown();
                } catch (Exception e) {
                    System.out.println("ERROR : " + e);
                    e.printStackTrace(System.out);
                }
            }
        }
        
        HelloImpl.java
        import HelloApp.*;
        import org.omg.CORBA.*;
        import org.omg.PortableServer.*;
        
        public class HelloImpl extends HelloPOA {
            private ORB orb;
        
            public void setORB(ORB orb_val) {
                orb = orb_val;
            }
        
            public String sayHello() {
                return "Hello, CORBA world!";
            }
        
            public void shutdown() {
                orb.shutdown(false);  // Shutdown the ORB
            }
        }
        
        HelloServer.java
        import HelloApp.*;
        import org.omg.CORBA.*;
        import org.omg.PortableServer.*;
        import org.omg.CosNaming.*;
        import org.omg.CosNaming.NamingContextPackage.*;
        
        public class HelloServer {
            public static void main(String args[]) {
                try {
                    // Initialize the ORB
                    ORB orb = ORB.init(args, null);
        
                    // Get reference to Root POA and activate the POAManager
                    POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
                    rootpoa.the_POAManager().activate();
        
                    // Create servant and register it with the ORB
                    HelloImpl helloImpl = new HelloImpl();
                    helloImpl.setORB(orb);
        
                    // Get the object reference from the servant
                    org.omg.CORBA.Object ref = rootpoa.servant_to_reference(helloImpl);
                    Hello href = HelloHelper.narrow(ref);
        
                    // Get the Naming Service reference
                    org.omg.CORBA.Object objRef = orb.resolve_initial_references("NameService");
                    NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
        
                    // Bind the object reference in naming
                    String name = "Hello";
                    NameComponent path[] = ncRef.to_name(name);
                    ncRef.rebind(path, href);
        
                    System.out.println("HelloServer ready and waiting...");
        
                    // Wait for client requests
                    orb.run();
                } catch (Exception e) {
                    System.out.println("ERROR : " + e);
                    e.printStackTrace(System.out);
                }
                System.out.println("HelloServer Exiting...");
            }
        }
        
        STEPS:
        1. Compile the IDL File:
        Open Command Prompt and navigate to the folder where Hello.idl is saved.
        Use the idlj tool to compile the IDL file.
        This will generate the folder HelloApp which contains all the necessary stubs and skeletons.
        2. Compile All Java Files:
        Make sure the HelloApp folder is in the same directory.
        Compile the following Java files:
        HelloImpl.java
        HelloServer.java
        HelloClient.java
        This will also compile the helper and interface files inside the HelloApp folder.
        3. Start the ORB Daemon (tnameserv):
        In a new Command Prompt window, navigate to the same folder.
        Start the naming service using the command: tnameserv
        Keep this window open and running in the background.
        4. Start the Server:
        In another Command Prompt window, run the HelloServer class using the command: java HelloServer
        The server should display: "HelloServer ready and waiting..."
        5. Start the Client:
        In a new Command Prompt window, run the HelloClient class using the command: java HelloClient
        The client should display the message: "Hello, CORBA world!" and then trigger the server shutdown.
        6. Expected Server Output:
        When the client connects and invokes the remote method, the server should respond and then exit with:
        "HelloServer ready and waiting..."
        "HelloServer Exiting..."
        ----------------------------------------------------------------------------------------------------------------
        EXP4 Implementation of Group Communication:
        Group ChatServer.java
        import java.io.*;
        import java.net.*;
        import java.util.*;
        
        // Server Class
        class GroupChatServer {
            private static Set<ClientHandler> clientHandlers = Collections.synchronizedSet(new HashSet<>());
        
            public static void main(String[] args) {
                try (ServerSocket serverSocket = new ServerSocket(12345)) {
                    System.out.println("Group Chat Server started on port 12345");
                    while (true) {
                        Socket clientSocket = serverSocket.accept();
                        ClientHandler clientHandler = new ClientHandler(clientSocket);
                        clientHandlers.add(clientHandler);
                        clientHandler.start();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        
            static class ClientHandler extends Thread {
                private Socket socket;
                private String username;
                private PrintWriter out;
        
                public ClientHandler(Socket socket) {
                    this.socket = socket;
                }
        
                @Override
                public void run() {
                    try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
                        out = new PrintWriter(socket.getOutputStream(), true);
        
                        // Read the username from the client
                        username = in.readLine();
                        broadcastMessage(username + " has joined the chat.");
        
                        String message;
                        while ((message = in.readLine()) != null) {
                            broadcastMessage(message);
                        }
                    } catch (IOException e) {
                        System.out.println("Client disconnected: " + socket);
                    } finally {
                        clientHandlers.remove(this);
                        broadcastMessage(username + " has left the chat.");
                        try {
                            socket.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
        
                private void broadcastMessage(String message) {
                    synchronized (clientHandlers) {
                        for (ClientHandler clientHandler : clientHandlers) {
                            if (clientHandler != this) {
                                clientHandler.sendMessage(message);
                            }
                        }
                    }
                }
        
                private void sendMessage(String message) {
                    out.println(message);
                }
            }
        }
        
        
        GroupChatClient.java
        import java.io.*;
        import java.net.*;
        
        // Client Class
        class GroupChatClient {
            public static void main(String[] args) {
                try (Socket socket = new Socket("localhost", 12345);
                     BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));
                     BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                     PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
        
                    System.out.print("Enter your username: ");
                    String username = userInput.readLine();
                    out.println(username);
                    System.out.println("Connected to Group Chat Server as " + username);
        
                    // Thread to read messages from server
                    Thread readThread = new Thread(() -> {
                        String message;
                        try {
                            while ((message = in.readLine()) != null) {
                                System.out.println(message);
                            }
                        } catch (IOException e) {
                            System.out.println("Disconnected from server.");
                        }
                    });
                    readThread.start();
        
                    // Read user input and send to server
                    String userMessage;
                    while ((userMessage = userInput.readLine()) != null) {
                        out.println(username + ": " + userMessage);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        STEPS:
        1. Compile All Java Files:
        Open Command Prompt and navigate to the folder where your Java files are saved.
        Compile both the server and client files using the following command:
        javac GroupChatServer.java GroupChatClient.java
        This will generate the necessary .class files for both the server and client.
        2. Run the Server:
        In the Command Prompt, start the server by running the compiled GroupChatServer class using the command:
        java GroupChatServer
        The server will start and display:
        "Group Chat Server started on port 12345"
        The server will wait for clients to connect.
        3. Join Multiple Clients to the Server:
        Open multiple Command Prompt windows (one for each client).
        In each window, run the client by using the following command:
        java GroupChatClient
        Each client will be prompted to enter a username.
        After entering the username, the client will be connected to the server.
        The server will display when clients join or leave the chat (e.g., "username has joined the chat").
        4. Sending Messages:
        Once connected, each client can type messages in their Command Prompt window.
        Each message typed by a client will be sent to the server and broadcasted to all other connected clients.
        All clients will see the messages sent by others.
        For example, if client A sends "Hello!", client B and client C will see the message in their Command Prompt window.
        ----------------------------------------------------------------------------------------------------------------
        EXP5 Implementation of Clock Synchronization algorithm:
        DistributedSystemSimulation .java
        import java.util.*;
        import java.text.SimpleDateFormat;
        
        class Process {
            private int id;
            private LamportClock clock;
            private List<Event> eventLog;
        
            public Process(int id) {
                this.id = id;
                this.clock = new LamportClock();
                this.eventLog = new ArrayList<>();
            }
        
            public void executeLocalEvent(String description) {
                clock.tick();
                logEvent(description);
            }
        
            public void sendMessage(Process receiver, String message) {
                clock.sendEvent();
                logEvent("Sent message to Process " + receiver.getId() + ": " + message);
                receiver.receiveMessage(this, clock.getClock(), message);
            }
        
            public void receiveMessage(Process sender, int messageClock, String message) {
                clock.receiveEvent(messageClock);
                logEvent("Received message from Process " + sender.getId() + ": " + message);
            }
        
            private void logEvent(String description) {
                eventLog.add(new Event(clock.getClock(), description));
            }
        
            public int getId() {
                return id;
            }
        
            public int getCurrentClock() {
                return clock.getClock();
            }
        
            public List<Event> getEventLog() {
                return eventLog;
            }
        }
        
        class LamportClock {
            private int clock;
        
            public LamportClock() {
                clock = 0;
            }
        
            public synchronized void tick() {
                clock++;
            }
        
            public synchronized void sendEvent() {
                clock++;
            }
        
            public synchronized void receiveEvent(int receivedClock) {
                clock = Math.max(clock, receivedClock) + 1;
            }
        
            public int getClock() {
                return clock;
            }
        }
        
        class Event {
            private final int timestamp;
            private final String description;
            private final String realTime;
        
            public Event(int timestamp, String description) {
                this.timestamp = timestamp;
                this.description = description;
                this.realTime = new SimpleDateFormat("HH:mm:ss.SSS").format(new Date());
            }
        
            @Override
            public String toString() {
                return String.format("[%s] (Logical Time: %d) %s", realTime, timestamp, description);
            }
        }
        
        public class DistributedSystemSimulation {
            private static final List<Process> processes = new ArrayList<>();
        
            public static void main(String[] args) {
                for (int i = 1; i <= 3; i++) {
                    processes.add(new Process(i));
                }
        
                System.out.println("Initial System State:");
                printSystemState();
        
                simulateEvents();
        
                System.out.println("\nFinal System State:");
                printSystemState();
        
                System.out.println("\nDetailed Event Logs:");
                printEventLogs();
            }
        
            private static void simulateEvents() {
                System.out.println("\nSimulating distributed system events...\n");
        
                processes.get(0).executeLocalEvent("Local computation");
        
                processes.get(0).sendMessage(processes.get(1), "Hello Process 2");
        
                processes.get(1).executeLocalEvent("Processing received data");
        
                processes.get(1).sendMessage(processes.get(2), "Forwarding to Process 3");
        
                processes.get(2).executeLocalEvent("Analyzing received data");
        
                processes.get(2).sendMessage(processes.get(0), "Sending results back");
            }
        
            private static void printSystemState() {
                for (Process p : processes) {
                    System.out.printf("Process %d - Logical Clock: %d%n",
                                    p.getId(), p.getCurrentClock());
                }
            }
        
            private static void printEventLogs() {
                for (Process p : processes) {
                    System.out.printf("%nProcess %d Event Log:%n", p.getId());
                    for (Event event : p.getEventLog()) {
                        System.out.println(event);
                    }
                }
            }
        }
        
        STEPS:
        1. Compile and Run the Program:
        Open Command Prompt (or terminal) and navigate to the folder where the Java file is saved.
        Compile the Java file using the following command:
        javac DistributedSystemSimulation.java
        Once compiled, run the program with the command:
        java DistributedSystemSimulation
        ----------------------------------------------------------------------------------------------------------------
        EXP6 Implementation of Election Algorithm:
        Bully algorithm:
        import java.util.Scanner;
        
        class Bully {
            static int n;
            static int coordinator;
            static int[] processes;
            static boolean[] active;
        
            public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                System.out.print("Enter number of processes: ");
                n = sc.nextInt();
                processes = new int[n];
                active = new boolean[n];
        
                System.out.println("Enter process IDs:");
                for (int i = 0; i < n; i++) {
                    processes[i] = sc.nextInt();
                    active[i] = true;
                }
        
                System.out.print("Enter process initiating election (index): ");
                int initiator = sc.nextInt();
               
                startElection(initiator);
               
                System.out.println("Final Coordinator: " + coordinator);
                sc.close();
            }
        
            static void startElection(int initiatorIndex) {
                System.out.println("Process " + processes[initiatorIndex] + " initiates election");
               
                // Send election messages to all higher processes
                boolean higherExists = false;
               
                for (int i = 0; i < n; i++) {
                    if (active[i] && processes[i] > processes[initiatorIndex]) {
                        System.out.println("Process " + processes[initiatorIndex] + " sends election message to process " + processes[i]);
                        higherExists = true;
                       
                        // Higher process responds with OK
                        System.out.println("Process " + processes[i] + " responds with OK to " + processes[initiatorIndex]);
                       
                        // Higher process starts its own election
                        startElection(i);
                        break;
                    }
                }
               
                // If no higher process exists or responds, this process becomes coordinator
                if (!higherExists) {
                    coordinator = processes[initiatorIndex];
                    System.out.println("Process " + coordinator + " becomes the coordinator");
                   
                    // Announce to all other processes
                    for (int i = 0; i < n; i++) {
                        if (i != initiatorIndex && active[i]) {
                            System.out.println("Process " + coordinator + " sends coordinator message to process " + processes[i]);
                        }
                    }
                }
            }
        }
        STEPS:
        1. Compile and Run the Program:
        Open Command Prompt (or terminal) and navigate to the folder where the Java file is saved.
        Compile the Java file using the following command:
        javac Bully.java
        Once compiled, run the program with the command:
        java Bully
        
        Sample Input:
        Enter number of processes: 5
        Enter process IDs:
        1 2 3 4 5
        Enter process initiating election (index): 2
        
        
        Ring Algorithm:
        import java.util.ArrayList;
        import java.util.List;
        import java.util.Scanner;
        
        class RingElection {
            static int n; // Number of processes
            static int[] processes; // Array of process IDs
        
            public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
        
                // Input: Number of processes
                System.out.print("Enter number of processes: ");
                n = sc.nextInt();
                processes = new int[n];
        
                // Input: Process IDs
                System.out.println("Enter unique process IDs:");
                for (int i = 0; i < n; i++) {
                    processes[i] = sc.nextInt();
                }
        
                // Input: Initiator process
                System.out.print("Enter the index of process initiating election (0 to " + (n - 1) + "): ");
                int initiator = sc.nextInt();
        
                // Validate initiator index
                if (initiator < 0 || initiator >= n) {
                    System.out.println("Invalid initiator index. Exiting...");
                    sc.close();
                    return;
                }
        
                startElection(initiator);
                sc.close();
            }
        
            static void startElection(int initiator) {
                List<Integer> electionMessage = new ArrayList<>();
                int current = initiator;
        
                System.out.println("\nElection process started by Process " + processes[initiator]);
        
                // Pass the election message around the ring
                do {
                    int next = (current + 1) % n; // Circular ring structure
                    electionMessage.add(processes[current]); // Append current process ID
                    System.out.println("Process " + processes[current] + " passes election message to Process " + processes[next] +
                                       " with message: " + electionMessage);
                    current = next;
                } while (current != initiator);
        
                // Find the highest process ID
                int coordinator = electionMessage.stream().max(Integer::compareTo).get();
        
                System.out.println("\nFinal message received at initiator: " + electionMessage);
                System.out.println("Process " + coordinator + " is elected as the new Coordinator.");
            }
        }
        STEPS:
        1. Compile and Run the Program:
        Open Command Prompt (or terminal) and navigate to the folder where the Java file is saved.
        Compile the Java file using the following command:
        javac RingElection.java
        Once compiled, run the program with the command:
        java RingElection
        
        Sample Input:
        Enter number of processes: 4
        Enter unique process IDs:
        1 2 3 4
        Enter the index of process initiating election (0 to 3): 2
        ----------------------------------------------------------------------------------------------------------------
        EXP7 Implementation of Mutual Exclusion Algorithm:
        import java.util.*;
        
        class RicartAgrawala {
            private final int processId;
            private final int numProcesses;
            private int timestamp = 0;
            private boolean inCriticalSection = false;
            private final Set<Integer> repliesReceived = new HashSet<>();
            private final Queue<Integer> deferredReplies = new LinkedList<>();
        
            public RicartAgrawala(int processId, int numProcesses) {
                this.processId = processId;
                this.numProcesses = numProcesses;
            }
        
            public void requestCriticalSection() {
                timestamp++;
                repliesReceived.clear();
                log("Requesting critical section with timestamp " + timestamp);
        
                // Request from all other processes
                for (int i = 0; i < numProcesses; i++) {
                    if (i != processId) sendRequest(i);
                }
        
                // Wait until all replies are received
                while (repliesReceived.size() < numProcesses - 1) {
                    try { Thread.sleep(500); } catch (InterruptedException ignored) {}
                    log("Waiting for replies... Received " + repliesReceived.size() + "/" + (numProcesses-1));
                }
        
                enterCriticalSection();
            }
        
            private void sendRequest(int toProcess) {
                log("Sending request to P" + toProcess);
                // Simulate sending request to another process
                receiveRequest(toProcess, timestamp);
            }
        
            public void receiveRequest(int fromProcess, int requestTimestamp) {
                timestamp = Math.max(timestamp, requestTimestamp) + 1;
               
                if (inCriticalSection ||
                    (timestamp < requestTimestamp) ||
                    (timestamp == requestTimestamp && processId < fromProcess)) {
                    // Defer the reply
                    deferredReplies.add(fromProcess);
                    log("Deferring reply to P" + fromProcess);
                } else {
                    // Send reply immediately
                    sendReply(fromProcess);
                }
            }
        
            private void sendReply(int toProcess) {
                log("Sending reply to P" + toProcess);
                // Simulate receiving reply
                repliesReceived.add(toProcess);
            }
        
            private void enterCriticalSection() {
                log("ENTERING CRITICAL SECTION");
                inCriticalSection = true;
               
                // Simulate work in critical section
                try { Thread.sleep(2000); } catch (InterruptedException ignored) {}
               
                exitCriticalSection();
            }
        
            private void exitCriticalSection() {
                log("EXITING CRITICAL SECTION");
                inCriticalSection = false;
               
                // Send deferred replies
                log("Processing " + deferredReplies.size() + " deferred replies");
                while (!deferredReplies.isEmpty()) {
                    sendReply(deferredReplies.poll());
                }
            }
           
            private void log(String message) {
                System.out.println(String.format("[P%d] TS=%d: %s",
                                   processId, timestamp, message));
            }
        
            public static void main(String[] args) {
                int numProcesses = 3;
                RicartAgrawala[] processes = new RicartAgrawala[numProcesses];
        
                // Create processes
                for (int i = 0; i < numProcesses; i++) {
                    processes[i] = new RicartAgrawala(i, numProcesses);
                }
        
                System.out.println("===== RICART-AGRAWALA MUTUAL EXCLUSION DEMONSTRATION =====");
                System.out.println("Starting " + numProcesses + " processes...");
               
                // Start processes with slight delays to see interactions
                new Thread(() -> {
                    try { Thread.sleep(100); } catch (InterruptedException e) {}
                    processes[0].requestCriticalSection();
                }).start();
               
                new Thread(() -> {
                    try { Thread.sleep(300); } catch (InterruptedException e) {}
                    processes[1].requestCriticalSection();
                }).start();
               
                new Thread(() -> {
                    try { Thread.sleep(500); } catch (InterruptedException e) {}
                    processes[2].requestCriticalSection();
                }).start();
            }
        }
        
        STEPS:
        1. Compile and Run the Program:
        Open Command Prompt (or terminal) and navigate to the folder where the Java file is saved.
        Compile the Java file using the following command:
        javac RicartAgrawala.java
        Once compiled, run the program with the command:
        java RicartAgrawala
        ----------------------------------------------------------------------------------------------------------------
        EXP8 Implementation of Load Balancing Algorithm:
        import java.util.*;
        
        class Server {
            private final int id;
            private final List<String> processes;
        
            public Server(int id) {
                this.id = id;
                this.processes = new ArrayList<>();
            }
        
            public int getId() {
                return id;
            }
        
            public void addProcess(String process) {
                processes.add(process);
            }
        
            public void removeProcess(String process) {
                processes.remove(process);
            }
        
            public List<String> getProcesses() {
                return processes;
            }
        
            public void display() {
                System.out.println("+----------------------+\n| Server " + id + " Processes  |\n+----------------------+");
                if (processes.isEmpty()) {
                    System.out.println("| No processes assigned |\n+----------------------+\n");
                } else {
                    for (String process : processes) {
                        System.out.println("| " + process);
                    }
                    System.out.println("+----------------------+");
                }
            }
        }
        
        class LoadBalancer {
            private final List<Server> servers;
            private int currentIndex = 0;
        
            public LoadBalancer() {
                servers = new ArrayList<>();
            }
        
            public void addServer() {
                servers.add(new Server(servers.size() + 1));
                System.out.println("\nNew Server Added: Server " + servers.size());
            }
        
            public void removeServer(int id) {
                servers.removeIf(server -> server.getId() == id);
                System.out.println("\nServer " + id + " Removed");
            }
        
            public void addProcess(String process) {
                if (servers.isEmpty()) {
                    System.out.println("\nNo Servers Available! Please add a server first.");
                    return;
                }
                servers.get(currentIndex).addProcess(process);
                System.out.println("\nProcess '" + process + "' assigned to Server " + servers.get(currentIndex).getId());
                currentIndex = (currentIndex + 1) % servers.size();
            }
        
            public void removeProcess(String process) {
                for (Server server : servers) {
                    if (server.getProcesses().contains(process)) {
                        server.removeProcess(process);
                        System.out.println("\nProcess '" + process + "' Removed from Server " + server.getId());
                        return;
                    }
                }
                System.out.println("\nProcess '" + process + "' Not Found!");
            }
        
            public void displayServers() {
                System.out.println("\n========================");
                System.out.println("       SERVER LIST       ");
                System.out.println("========================");
                if (servers.isEmpty()) {
                    System.out.println("No Servers Available!");
                } else {
                    for (Server server : servers) {
                        server.display();
                    }
                }
            }
        }
        
        public class LoadBalancingDemo {
            public static void main(String[] args) {
                LoadBalancer loadBalancer = new LoadBalancer();
                Scanner scanner = new Scanner(System.in);
               
                while (true) {
                    System.out.println("\n===============================");
                    System.out.println("    LOAD BALANCER MENU   ");
                    System.out.println("===============================");
                    System.out.println("1. Add Server");
                    System.out.println("2. Remove Server");
                    System.out.println("3. Add Process");
                    System.out.println("4. Remove Process");
                    System.out.println("5. Display Servers");
                    System.out.println("6. Exit");
                    System.out.print("Enter choice: ");
                   
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline
                   
                    switch (choice) {
                        case 1:
                            loadBalancer.addServer();
                            break;
                        case 2:
                            System.out.print("Enter Server ID to remove: ");
                            int serverId = scanner.nextInt();
                            loadBalancer.removeServer(serverId);
                            break;
                        case 3:
                            System.out.print("Enter Process Name: ");
                            String process = scanner.nextLine();
                            loadBalancer.addProcess(process);
                            break;
                        case 4:
                            System.out.print("Enter Process Name to remove: ");
                            String processToRemove = scanner.nextLine();
                            loadBalancer.removeProcess(processToRemove);
                            break;
                        case 5:
                            loadBalancer.displayServers();
                            break;
                        case 6:
                            System.out.println("\nExiting Load Balancer Simulation. Goodbye!");
                            scanner.close();
                            return;
                        default:
                            System.out.println("\nInvalid Choice! Please select a valid option.");
                    }
                }
            }
        }
        
        STEPS:
        1.Compile the Program
        Open terminal and navigate to the directory containing the file LoadBalancingDemo.java.
        Command to compile: javac LoadBalancingDemo.java
        2.Run the Program
        Command to run: java LoadBalancingDemo
        3.Sample Input / User Interaction
        Below is a sample session demonstrating how the Load Balancer system works.   
        Explanation of Menu Options:
        1 - Adds a new server
        2 - Removes a server by its ID
        3 - Adds a process to the next server using Round-Robin scheduling
        4 - Removes a process by its name
        5 - Displays all servers and their assigned processes
        6 - Exits the program
        ----------------------------------------------------------------------------------------------------------------
        EXP9 Case study on Distributed Shared Memory:
        SharedMemoryServer.java
        import java.io.*;
        import java.net.*;
        
        public class SharedMemoryServer {
            private static int sharedVariable = 50; // Initial value of shared variable
        
            public static void main(String[] args) {
                try (ServerSocket serverSocket = new ServerSocket(5000)) {
                    System.out.println("SharedMemoryServer started on port 5000...");
        
                    while (true) {
                        Socket clientSocket = serverSocket.accept();
                        new ClientHandler(clientSocket).start();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        
            private static class ClientHandler extends Thread {
                private final Socket socket;
        
                public ClientHandler(Socket socket) {
                    this.socket = socket;
                }
        
                @Override
                public void run() {
                    try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                         PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
        
                        out.println("Connected to SharedMemoryServer. Type 'exit' to quit.");
                        String command;
        
                        while ((command = in.readLine()) != null) {
                            if (command.equalsIgnoreCase("get")) {
                                out.println("Accessed Shared Variable: " + sharedVariable);
                            } else if (command.equalsIgnoreCase("set")) {
                                out.println("Enter Value:");
                                try {
                                    int newValue = Integer.parseInt(in.readLine());
                                    sharedVariable = newValue;
                                    out.println("Updated Shared Variable: " + sharedVariable);
                                } catch (NumberFormatException e) {
                                    out.println("Invalid Value. Please enter an integer.");
                                }
                            } else if (command.equalsIgnoreCase("exit")) {
                                out.println("Disconnecting...");
                                break;
                            } else {
                                out.println("Invalid Command");
                            }
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        
        
        SharedMemoryClient.java
        import java.io.*;
        import java.net.*;
        
        public class SharedMemoryClient {
            public static void main(String[] args) {
                try (Socket socket = new Socket("localhost", 5000);
                     BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                     PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
                     BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in))) {
        
                    System.out.println(in.readLine()); // Welcome message
        
                    String command;
                    while (true) {
                        System.out.print("Enter Command (get/set/exit): ");
                        command = userInput.readLine();
                        out.println(command);
        
                        if (command.equalsIgnoreCase("set")) {
                            System.out.print("Enter Value: ");
                            out.println(userInput.readLine());
                        }
        
                        String response = in.readLine();
                        System.out.println(response);
        
                        if (command.equalsIgnoreCase("exit")) {
                            break;
                        }
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        STEPS:
        1. Start the Server
        First, compile and run the SharedMemoryServer.java to start the server.
        Compile the Server:
        Open your terminal and navigate to the directory where SharedMemoryServer.java is located.
        Compile the server using:
        javac SharedMemoryServer.java
        Run the Server:
        After compilation, run the server:
        java SharedMemoryServer
        The server will start and listen on port 5000 for incoming connections.
        2. Start the Clients
        Now, you will start two clients using separate terminals.
        Compile the Client:
        In a separate terminal, navigate to the directory where SharedMemoryClient.java is located.
        Compile the client:
        javac SharedMemoryClient.java
        Run the First Client:
        java SharedMemoryClient
        Run the Second Client:
        Open another terminal and run the second client:
        java SharedMemoryClient
        3. Obtain Value Using Client 1
        Once Client 1 is running, type get to retrieve the current value of the shared variable.
        Example command:
        Enter Command (get/set/exit): get
        Client 1 will receive the following response:
        Accessed Shared Variable: 50
        4. Set Value Using Client 1
        
        Client 1 can set the shared variable by typing set and entering a new value.
        
        Example command:
        Enter Command (get/set/exit): set
        Enter Value: 100
        Client 1 will receive:
        Updated Shared Variable: 100
        5. Check the Value Using Client 2
        Now, Client 2 can check the updated value of the shared variable by typing get.
        
        Example command:
        Enter Command (get/set/exit): get
        Client 2 will receive:
        Accessed Shared Variable: 100
        
        Sample Interaction
        Server Terminal Output (SharedMemoryServer.java)
        SharedMemoryServer started on port 5000...
        ----------------------------------------------------------------------------------------------------------------
        ----------------------------------------------------------------------------------------------------------------
    </pre>
  </body>
</html>
